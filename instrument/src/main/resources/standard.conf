props = {
  output = "/tmp/spark-trace"
  overhead = true
}
targets = {
  "org.apache.spark" = [
    { type = rpc },
    { type = event, class = "scheduler.DAGSchedulerEventProcessLoop",         method = "doOnReceive" },
    { type = event, class = "scheduler.TaskSchedulerImpl",                    method = "submitTasks" },
    { type = event, class = "scheduler.TaskSchedulerImpl",                    method = "taskSetFinished" },
    { type = event, class = "storage.BlockManager",                           method = "getBlockData" },
    { type = event, class = "storage.BlockManager",                           method = "get" },
    { type = event, class = "storage.BlockManager",                           method = "doPut" },
    { type = event, class = "storage.BlockManager",                           method = "dropFromMemory" },
    { type = event, class = "storage.BlockManager",                           method = "removeBlock" },
    { type = event, class = "storage.BlockManagerMaster",                     method = "registerBlockManager" },
    { type = event, class = "storage.BlockManagerMaster",                     method = "updateBlockInfo" },
    { type = event, class = "storage.BlockManagerMaster",                     method = "removeBlock" },
    { type = event, class = "storage.BlockManagerMaster",                     method = "removeRdd" },
    { type = event, class = "storage.BlockManagerMaster",                     method = "removeShuffle" },
    { type = event, class = "storage.BlockManagerMaster",                     method = "removeBroadcast" },
    { type = event, class = "network.netty.NettyBlockTransferService",        method = "fetchBlocks" },
    { type = event, class = "network.netty.NettyBlockTransferService",        method = "uploadBlock" },
    { type = event, class = "shuffle.sort.SortShuffleManager",                method = "registerShuffle" },
    { type = event, class = "shuffle.sort.SortShuffleManager",                method = "unregisterShuffle" },
    { type = event, class = "MapOutputTrackerMaster",                         method = "registerShuffle" },
    { type = event, class = "MapOutputTrackerMaster",                         method = "unregisterShuffle" },
    { type = event, class = "SparkFirehoseListener",                          method = "*" },
    { type = span,  class = "rpc.RpcEnv$",                                    method = "create" }, # Instrumenting NettyRpcEnvFactory.create doesn't give results, for some reason
    { type = span,  class = "deploy.yarn.ApplicationMaster",                  method = "org$apache$spark$deploy$yarn$ApplicationMaster$$waitForSparkDriver" },
    { type = span,  class = "deploy.yarn.ApplicationMaster",                  method = "org$apache$spark$deploy$yarn$ApplicationMaster$$registerAM" },
  # { type = span,  class = "deploy.yarn.Client",                             method = "prepareLocalResources" },
  # { type = span,  class = "deploy.yarn.Client",                             method = "submitApplication" },
  # { type = span,  class = "deploy.yarn.Client",                             method = "Client" }, # FIXME Doesn't construct properly for some reason, so we get NPEs.
    { type = span,  class = "deploy.yarn.Client",                             method = "org$apache$spark$deploy$yarn$Client$$distribute$1" },
    { type = span,  class = "deploy.yarn.YarnAllocator",                      method = "allocateResources" },
    { type = span,  class = "deploy.yarn.ExecutorRunnable",                   method = "startContainer" },
    { type = span,  class = "scheduler.cluster.YarnClientSchedulerBackend",   method = "waitForApplication" },
    { type = span,  class = "SparkContext",                                   method = "createSparkEnv" },
    { type = span,  class = "SparkContext",                                   method = "SparkContext" },
    { type = span,  class = "metrics.MetricsSystem",                          method = "start" },
    { type = span,  class = "scheduler.TaskSchedulerImpl",                    method = "waitBackendReady" },
  # TODO Need FetchDriverProps in CoarseGrainedExecutorBackend.run
  ]
}
